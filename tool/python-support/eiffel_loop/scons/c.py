#	author: "Finnian Reilly"
#	copyright: "Copyright (c) 2001-2012 Finnian Reilly"
#	contact: "finnian at eiffel hyphen loop dot com"
#	license: "MIT license (See: en.wikipedia.org/wiki/MIT_License)"
#	date: "16 Dec 2011"
#	revision: "0.1"

import os, subprocess, zlib
from os import path

from SCons.Script.SConscript import Configure

global new_line
new_line = ''

def crc_32 (lines):
	prev = 0
	for line in lines:
		prev = zlib.crc32 (line, prev)
	return prev & 0xFFFFFFFF

def file_lines (file_path):
	result = []
	f = open (file_path, 'r')
	for line in f.readlines ():
		result.append (line.rstrip ())
	f.close ()
	return result

def put_export_entry (fout, line):
	if len (line) > 26:
		fout.write ('\t%s\n' % line [26:])

def drop_line (fout, line):
	pass

def set_dll_definitions (dll_path, def_path):
	cmd = ['dumpbin','/EXPORTS', dll_path]
	print cmd
	proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)

	fout = open (def_path, 'w')
	fout.write ('LIBRARY %s\n' % path.basename (dll_path))
	fout.write ('EXPORTS\n')

	done = False
	fn_put = drop_line
	while not done:
		line = proc.stdout.readline()
		if len (line) == 0:
			done = True

		elif line.find ('ordinal hint') > 0:
			fn_put = put_export_entry

		elif line.find ('Summary') > 0:
			fn_put = drop_line

		else:
			fn_put (fout, line.rstrip())
	
	fout.write ('\n')
	fout.close


# Convert Windows dll to def

def dll_def_generator (target, source, env):
	for i in range (0, len (source)):
		def_src_path = str (source [i])
		f_in = open (def_src_path, 'r')
		dll_name = f_in.readline ().rstrip()
		f_in.close
		target_dir = path.dirname (str (target [i]))
		dll_path = path.join (target_dir, dll_name)
		set_dll_definitions (dll_path, str (target [i]))


def has_ansi_C_standard_headers (conf):
	result = True
	# if the system has these, it probably has the rest of the ANSI C header files.
	for h in ['stdlib.h', 'stdarg.h', 'string.h', 'float.h']:
		if conf.CheckCHeader (h):
			pass
		else:
			result = False
			break
	return result
	
class CONFIG_HEADER (object):

	def __init__(self, conf, location):
		self.config_path = path.join (location, 'config.h')
		self.lines = ['// Generated by SCons', '// Do not edit', '']

		self.conf = conf
		
	def __set_defines_for_header_availability (self, headers, check):
		for h in headers:
			header_id = None
			h = path.normpath (h)
			for s in path.splitext (h)[0].split (os.sep):
				if header_id:
					header_id = header_id + '_' + s
				else:
					header_id = s
					
			self.lines.append ('/* Define to 1 if you have the <%s> header file. */' % h)
			if check (h):
				self.lines.extend (['#define HAVE_%s 1' % header_id.upper (), new_line])
				if h == 'locale.h':
					self.lines.extend (['#define HAVE_LC_MESSAGES 1', new_line])
			
			else:
				self.lines.extend (['/* #undef HAVE_%s */' % header_id.upper (), new_line])

	def set_defines_for_C_header_availability (self, headers):
		self.__set_defines_for_header_availability (headers, self.conf.CheckCHeader)

	def set_defines_for_CPP_header_availability (self, headers):
		self.__set_defines_for_header_availability (headers, self.conf.CheckCXXHeader)
				
	def set_defines_for_C_library_availability (self, libraries):
		for lib in libraries:
			self.lines.append ('/* Define to 1 if you have the \'%s\' library. (-l%s) */' % (lib, lib))
			if self.conf.CheckLib (lib):
				self.lines.extend (['#define HAVE_LIB%s 1' % lib.upper (), new_line])

	def set_defines_for_C_function_availability (self, functions):
		for func in functions:
			self.lines.append ('/* Define to 1 if you have the \'%s\' function.*/' % func)
			if self.conf.CheckFunc (func):
				self.lines.extend (['#define HAVE_%s 1' % func.upper (), new_line])
			else:
				self.lines.extend (['/* #undef HAVE_%s */' % func.upper (), new_line])

	def set_string_defines (self, define_tuples):
		for macro_name, str_value, description in define_tuples:
			if description:
				self.lines.append ('/* Define to the %s */' % description)
			self.lines.extend (['#define %s "%s"' % (macro_name, str_value), new_line])
			
	def set_defines (self, define_tuples):
		for macro_name, value, description in define_tuples:
			if description:
				self.lines.append ('/* Define to %s %s */' % (value, description))
			self.lines.extend (['#define %s %s' % (macro_name, value), new_line])
			
	def append_text (self, text):
		self.lines.extend (text.split ('\n'))
		
	def save (self):
		if path.exists (self.config_path):
			lines = file_lines (self.config_path)
			old_crc = crc_32 (lines); crc = crc_32 (self.lines)
		else:
			old_crc = 0; crc = 1

		if crc != old_crc:
			f = open (self.config_path, 'w')
			for line in self.lines:
				f.write (line + '\n')
			f.close ()
		
			

